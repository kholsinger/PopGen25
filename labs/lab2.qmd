---
title: Lab 2
theme: cosmo
bibliography: references.bib
engine: julia
execute:
  freeze: auto  # re-render only when source changes
---

# Data structures in genomics

Today's goal is two-fold:

1)  Learn to import and manipulate data tables either in `R` or `Julia`.

2)  Understand how genomic data files are structured, and play around with one.

I will supply both `Julia` and `R` code in the blocks below - it's up to you which you use. However, in either case I would recommend using some kind of IDE (integrated development environment). An IDE lets you interact with a programming language by seperating out your code writing from your code execution, and generally supplies lots of convenience functions. If you've already been using `R`, you are likely already using an IDE: `RStudio` (and if not, [try it](https://posit.co/download/rstudio-desktop/) or [positron](https://positron.posit.co/download.html) which is meant to replace it long run). `Pluto` actually functions as a lightweight IDE for `Julia`, but if you would like more bells and whistles, I will recommend some branch of `VSCode`, like [VSCodium](https://vscodium.com/). Setting it up should take you a few moments, but I am happy to help out.

Before we start coding, whichever language/IDE you have chosen, let's think about how you'll organize code. If you have done coding in the past, you are probably used to *everything* you write for a single project living in a single file. You are also therefore probably used to having to scroll gigantic files trying to find where some small piece of code is. More troublingly, if you have to redo something multiple times (say, loop through some function for different subsets of data), you probably have to remember to edit each instance of doing that method when you change it. I'll try to encourage you to write code in a way that is more modular: functions/approaches you reuse can live in a separate file, so that you can quickly find them, and edit them more consistently.

In the case of my own projects, I organize them in a way that lets me reuse code, and edit it more consistently, by taking some pointers from the software development world. A typical project directory for me looks like:

```         
project
|    README.md
|____data/
|    |_____raw_data.tsv
|    |_____genomic.vcf
|____scripts/
|____results/
|____src/
|    |____genomic_functions.jl
|    |____stats_functions.jl
|    |____plotting_functions.jl
|     
|____plots/
```

Unprocessed data files can live in the `data/` folder, letting you avoid editing them by accident and overwriting raw data. Scripts/pipelines to process the data go in `scripts/`, processed data that you don't want to regenerate/results tables go in `results/`, and most importantly, any custom code goes into `src/`.

## For this class:

Try working in the directory structure that you've been given with this repository. There is a folder including some `Julia` code I've written in `src/` , and over time it will be populated with more of my own solutions, but you might as well add your own. To avoid `git` issues when you pull code in future weeks (and later help me when I'm grading code submissions), create a file in `src/` called `last_name.R` or `last_name.jl`, depending on whether you are writing in `R` or `Julia`, respectively. Any *functions* you write - try to keep them in that file. Any scripts you work on for labs can live in the `labs` folder, just call them `lab_{number of lab}_{last name}.R` or `.jl` or `.sh` or whatever other format.

### A note on version control with git

Some of you are probably already used to using `git`. For others this might be an entirely new thing. I will not be enforcing, but I do strongly recommend you start getting acquainted with it - it will save you many headaches in the long run. [Check out this guide](https://swcarpentry.github.io/git-novice/) for a place to start.

## Virtual environments and package management

In different projects, you'll often use different sets of software packages/libraries for your programming language. To make your workflow fully replicable, it's a good idea to keep track of the package environment with some sort of environment management approach. Even if you are not worried about reporting your results eventually in a paper and having the correct package versions listed, consider a common work case: you run a script on your laptop and it runs *fine*. You then try to run it on data on the cluster, and it breaks: turns out a slightly different package version no longer behaves the way it does on your laptop - but you don't know that! Looking for help, you then go to send your code to your PI, and they cannot get it running either. So, a result you thought you had gets tossed because you assume you made a mistake *somewhere*, just not sure where. This can all be avoided by using virtual environments - when you send your code to the cluster, it should include a manifest of each package required AND its version. Same for when you send it to your PI.

You don't need to do this right now, but feel free to come back to this section after you've run through the lab and figure out what virtual environment works for you.

### R: `renv`

`renv` is the best approach to manage your packages in `R`. Getting it set up is relatively easy, and `Rstudio` comes with some utility tools for it. Follow the guide [here](https://rstudio.github.io/renv/).

In my personal experience, `R` ends up with frequent weird issues with packages, where some version of some library requires a new version of `R`, while a different package is not yet updated and therefore incompatible. For that (and other reasons we can talk about), I will recommend that you avoid looking for packages that do some task for you, and write your own code for it when possible, at least for this class.

### Julia: package environments

`Julia` has package environments built into its core, so there's nothing too special you need to do. If you are working using a `Pluto` notebook, for instance, the package environment is handled entirely for you. But as you probably noticed in last weeks lab - the startup time includes a whole lot of precompiling packages in the background. The way to make `Julia` quite a bit faster is to explicitly have a project file in your project directory. You do this as follows:

```{julia}
#| eval: false
using Pkg; Pkg.activate("/absolute/path/to/your/project/"); Pkg.instantiate()
```

What the above line will do is tell `Julia` to create two files in the project directory: `Manifest.toml` and `Project.toml`. These files just keep track of the versions of all of the packages that have been added to the project, so that when you start up the project, it knows there should be stored binaries for all of those packages (compatible with each other). As you add new packages, it'll handle downgrading/upgrading/finding a solution that works for all of the packages you want.

### Python: `conda`

Python has a few solutions, but probably the best is making a `conda` environment. It builds on top of python's own system `pip` and `pyenv`, but has great integration with the huge ecosystem of packages that exist in the `Python` world. See a guide [here](https://carpentries-incubator.github.io/introduction-to-conda-for-data-scientists/01-getting-started-with-conda/index.html).

# Buffalo 2021 data:

The first thing we'll do is learn how to import data/deal with data frames in either `R` or `Julia`.

## Data formats: 90% of the battle

You will find that in practice most bioinformatics is wrangling data formats. Every piece of software/software package has its own preferred format for data. This is part of the reason I stress the importance of understanding (and being able to write your own) code for performing various population genetic approaches. If you know how to calculate $\pi$, you will hopefully just figure out how to do that for the format you have the data in, rather than having to spend hours/days chasing format conversion down. In this and future weeks, I will give you a general run down of what you need to do with the data, and then give you some code/pointers as for how, but I'll leave the actual implementation to you.

## Looking at the data before importing it

It's useful to take a glance at the data before you try to import it. You can try to open the file using your operating system's choice of software, but Unix tools are built well to precisely do a quick glance. In the `labs/data` folder, there is a file called `buffalo.txt`. This is the data from [@Buffalo2021]. Before you import it, it's good to take a look at what the data actually looks like. We can do so in the terminal. Navigate to the right directory (if you are on Windows and using `wsl`, I can help you here). Once there, run the following

``` bash
head buffalo.txt
```

You should see something like:

``` bash
species phylum  habitat mating_system   range_cat       sexual_system   abbrv   neut_model_conf genome_species self_est maplen_data_source      diversity_data_source   site_type       hcn     num_markers     parpath pred_piimpact_of_sel    log10_size      log10_range     num_chr totalMb_covered ave_rec assembly_size   selfing map_length      genome_size     fecundity       propagule       bodymass_g      diversity       size    log10_diversitysocial   species_orig    is_terrestrial  n_occ   range   id      kingdom superphylum     subphylum       class  order    family  genus   clean_name      redlist_cat     log10_body_mass log10_body_mass_pred    log10_popsize  log10_density    log10_density_pred      pred_log10_body_mass    pred_log10_density      pred_log10_N    RS     log10_RS log10_map_length        species_lower
Abatus agassizi Echinodermata   NA      NA      NA      NA      NA      NA      NA      NA      NA      Romiguier et al.        NA      NA      NA      FALSE   NA      NA      -1.6108339156354674     6.633700542517746      NA       NA      NA      NA      NA      NA      NA      0.299   0.002   9.28    0.00727197      0.0245  -2.1383479214336867     FALSE   Abatus agassizi FALSE   72      4302298.533787006       NA      Animalia        NA     NA       Echinoidea      Spatangoida     Schizasteridae  Abatus  Abatus agassizi NA      -0.6534814211608199    -0.6405066270384477      11.065298198284022      4.431597655766276       4.42625265103009        -0.6547028847549656     4.432901908737623       11.066602451255369      175604021.7872247       8.244534458153213       NA     abatus agassizi
Acromyrmex echinatior   Arthropoda      NA      NA      NA      male.haploid    NA      NA      NA      NA     Stapley et al.   NA      NA      19      145     FALSE   NA      NA      -2.2596373105057563     5.61732386966055NA      NA      NA      NA      NA      20.338  0.335   NA      NA      NA      NA      0.0055  NA      TRUE   Acromyrmex echinatior    TRUE    105     414308.5250288181       574019  Animalia        Ecdysozoa       HexapodaInsecta Hymenoptera     Formicidae      Acromyrmex      Acromyrmex echinatior   NA      -2.7280036542040085    -2.7364907216649312      11.617818883879833      6.000495014219284       6.009905730795794       -2.7309804876823183     6.003335452336658       11.620659321997207      75328822.73251238       7.8769611801663055      1.3083082429982256      acromyrmex echinatior
Acropora millepora      Cnidaria        NA      NA      NA      hermaphrodite   NA      NA      NA      NA     Stapley et al.   NA      NA      14      429     FALSE   NA      NA      NA      7.795297039711985       NA     NA       NA      NA      NA      13.91   0.42    NA      NA      NA      NA      NA      NA      FALSE   Acropora millepora      FALSE   1613    62416159.05944288       52901   Animalia        NA      Anthozoa        AnthozoaScleractinia    Acroporidae     Acropora        Acropora millepora      NT      NA      NA      NA      NA     NA       NA      NA      NA      NA      NA      1.1433271299920464      acropora millepora
Acyrthosiphon pisum     Arthropoda      Terrestrial     Partial selfing Cosmopolitan    parthenogenic   NA     NA       NA      NA      Stapley et al.  Leffler et al.  NA      5       173     FALSE   NA      NA      -2.3979400086720375     7.080809415567688       NA      NA      NA      NA      NA      3.94    0.165   NA      NA     NA       0.0088125       0.004   -2.054900870000545      FALSE   Acyrthosiphon pisum     TRUE    2512    12045072.421827307      200572  Animalia        Ecdysozoa       Hexapoda        Insecta Hemiptera       Aphididae      Acyrthosiphon    Acyrthosiphon pisum     NA      -3.1702208566789927     -3.182279811406018      13.415739698676683      6.334930283108995       6.357104023822486       -3.173571874992307      6.338098183370152       13.41890759893784       3011268105.4568267      9.478749424239727       0.5954962218255742      acyrthosiphon pisum
Aedes aegypti   Arthropoda      Terrestrial     Obligatory outcrossing  Cosmopolitan    gonochorous     NA     NA       NA      NA      Stapley et al.  Leffler et al.  NA      3       2006    FALSE   NA      NA      -2.579631620142476      7.583115518888759       NA      NA      NA      NA      NA      2.35    0.94214 NA      NA     NA       0.01421 0.0026325       -1.8474059220725303     FALSE   Aedes aegypti   TRUE    30000   38292658.52071776       126240  Animalia        Ecdysozoa       Hexapoda        Insecta Diptera Culicidae       Aedes   Aedes aegypti   NA      -3.7511723290864785     -3.753271310092434      14.35740153216626       6.774286013277501      6.770873848375246        -3.7550149230997683     6.777884108505123       14.360999627393882      14546119096.189085      10.162747139031236      0.37106786227173627     aedes aegypti
Aedes albopictus        Arthropoda      NA      NA      NA      gonochorous     NA      NA      NA      NA     Stapley et al.   NA      NA      3       172     FALSE   NA      NA      -2.580044251510242      7.445784591347202       NA      NA      NA      NA      NA      2.126   1.09047 NA      NA      NA      NA      0.00263 NA     FALSE    Aedes albopictus        TRUE    30000   27911590.92003886       126244  Animalia        Ecdysozoa      Hexapoda Insecta Diptera Culicidae       Aedes   Aedes albopictus        NA      -3.7524917009535947     -3.753551590575262      14.221068404987681      6.775283813640479       6.779607141395379       -3.756335411361592     6.778882885863879        14.224667477211081      10612772212.942533      10.025828842857445      0.32756326018727794     aedes albopictus
Agelaius phoeniceus     Chordata        Terrestrial     Obligatory outcrossing  Broad endemic   NA      NA     NA       NA      NA      NA      Leffler et al.  NA      NA      NA      FALSE   NA      NA      -0.6575773191777937     7.119596489010348       NA      NA      NA      NA      NA      NA      NA      NA      NA      NA     0.0059   0.22    -2.2291479883578558     FALSE   Agelaius phoeniceus     TRUE    30000   13170324.908019817     179045   Animalia        NA      Vertebrata      Aves    Passeriformes   Icteridae       Agelaius        Agelaius phoeniceus     LC      2.394517431468307       2.39143600201306        9.246086360300021       2.126489871289673       2.117521308655038       2.3958750510517968      2.125537079006005       9.245133568016353       59865113.218271896      7.7771738081881425      NA      agelaius phoeniceus
Ailuropoda melanoleuca  Chordata        Terrestrial     Obligatory outcrossing  Narrow endemic  NA      NA     NA       NA      NA      NA      Leffler et al.  NA      NA      NA      FALSE   NA      NA      0.18730634078622424     6.150386149916167       NA      NA      NA      NA      NA      NA      NA      NA      NA      NA     0.00135  1.53924 -2.869666231504994      FALSE   Ailuropoda melanoleuca  TRUE    130     1413794.051074382      621845   Animalia        NA      Vertebrata      Mammalia        Carnivora       Ursidae Ailuropoda      Ailuropoda melanoleuca  VU      5.095998266476374       5.1000064327850865      6.2338291555483885      0.08344300563222148     0.08933867763248815     5.099641760862692       0.08048976492485682     6.2308759148410235      918501.3715043671       5.963079809129942       NA      ailuropoda melanoleuca
Allolobophora chlorotica        Annelida        NA      NA      NA      NA      NA      NA      NA      NA     NA       Romiguier et al.        NA      NA      NA      FALSE   NA      NA      -1.2596373105057561     6.580581413049396       NA      NA      NA      NA      NA      NA      NA      0.74    2.38e-4 0.3     0.0449719      0.055    -1.3470587637088103     FALSE   Allolobophora chlorotica        TRUE    3070    3806987.16874359       974862   Animalia        Lophozoa        NA      Clitellata      Opisthopora     Lumbricidae     Allolobophora  Allolobophora chlorotica NA      0.46945531325089346     0.4661403969117158      10.162936554916952      3.582355141867555       3.582435448831861       0.4691840295555272      3.5828278594116822      10.163409272461077     69217948.52261072        7.840218723555152       NA      allolobophora chlorotica
adagilis@4ZMQ374:/mnt/c/Projects/PopGen25/labs/data$ head -2 buffalo_2021.txt 
species phylum  habitat mating_system   range_cat       sexual_system   abbrv   neut_model_conf genome_species self_est maplen_data_source      diversity_data_source   site_type       hcn     num_markers     parpath pred_piimpact_of_sel    log10_size      log10_range     num_chr totalMb_covered ave_rec assembly_size   selfing map_length      genome_size     fecundity       propagule       bodymass_g      diversity       size    log10_diversitysocial   species_orig    is_terrestrial  n_occ   range   id      kingdom superphylum     subphylum       class  order    family  genus   clean_name      redlist_cat     log10_body_mass log10_body_mass_pred    log10_popsize  log10_density    log10_density_pred      pred_log10_body_mass    pred_log10_density      pred_log10_N    RS     log10_RS log10_map_length        species_lower
Abatus agassizi Echinodermata   NA      NA      NA      NA      NA      NA      NA      NA      NA      Romiguier et al.        NA      NA      NA      FALSE   NA      NA      -1.6108339156354674     6.633700542517746      NA       NA      NA      NA      NA      NA      NA      0.299   0.002   9.28    0.00727197      0.0245  -2.1383479214336867     FALSE   Abatus agassizi FALSE   72      4302298.533787006       NA      Animalia        NA     NA       Echinoidea      Spatangoida     Schizasteridae  Abatus  Abatus agassizi NA      -0.6534814211608199    -0.6405066270384477      11.065298198284022      4.431597655766276       4.42625265103009        -0.6547028847549656     4.432901908737623       11.066602451255369      175604021.7872247       8.244534458153213       NA     abatus agassizi
```

This looks like a tab seperated file (usually ending in .tsv). Tabs are special characters (often denoted as `\t`) are one of the two most common ways to delimit fields in the data. Many data files adopt a general structure typical to .tsv files:

1\) The first line is a header - indicating the names of the columns of data.

2\) The data is often organized as a *wide* data format: each row represents a single data point, including all of its metadata. Long data formats will separate out the metadata. This can be sometimes useful when the data is sparse (lots of missing values) as it is in this dataset, but it is harder to parse for humans at a glance.

There are various packages/approaches to reading in data in most programming languages. The ones I'll recommend for `R` and `Julia` focus on making the user's life as simple as possible while catching *most* exceptions.

## R

If you are working in `R`, open up your IDE and create a new file that you'll store the commands you wrote here in. If you are using `RStudio`, consider creating a new R Markdown document. This is similar to the format this webpage is written in, with a mixture of text and executable code. Having good comments around what you've done is very helpful in the long run, so some form of Markdown can be great. Your screen should look something like this:

![](images/Screenshot 2025-09-03 102539.png){fig-align="center"}

You'll run code in the bottom left, and keep versions that ran/worked how you wanted in the top right.

`R` has a variety of libraries to read in data. `readr` is the one I will recommend, because it does a good job of automatically detecting various idiosyncracies in the data. To read the datafile in with `readr`, you'll need to run the following:

```{r}
#| eval: false
#| echo: true
require(readr)

buffalo_data <- read_tsv("<path to your repository>/labs/data/buffalo_2021.txt",sep="\t")
```

This will read the data in as a `tibble` object that is easy to work with in `R`. If you get an error stating the package does not exist, you ned to first install it. This can be done by running `install.packages("readr")`. You'll then need to rerun the above block of code.

## Julia

So, you've chosen `Julia`! If you are using `Pluto` as your coding environment, starting out will be as simple as creating a new Pluto notebook, and you can begin coding. If you are using VSCodium (or one of its branches), there'll be a bit more setup in getting some `Julia` extensions installed, and figuring out the oh-so-many options that Virtual Studio tosses at you. But once you do, open the folder for this repository, and create a new `.jl` file somewhere and you can start coding. I recommend opening this repository only because you'll then be able to piggyback off of the package environment for the course (which already has a bunch of packages you'll probably want/need).

The way to activate that environment (assuming you run julia from the repository folder) is to open `Julia` and then hit the `]` key. This will enter you into `Pkg` mode (the line should start with `Pkg>`. Then type:

```{julia}
#| eval: false
#| echo: true
activate "PopGen25"
instantiate
```

And all of the necessary packages should be installed and precompiled. Hit the backspace key to exit `Pkg` mode (the terminal should start with `julia>` ).

Julia's `CSV` package does a good job reading in many data formats, but it also wants to know what kind of object you will turn the data into (a matrix, a vector, a dataframe?). We'll go for a DataFrame object:

```{julia}
#| eval: false
#| echo: true
using CSV, DataFrames

buffalo_data = CSV.read("<path to your repository>/labs/data/buffalo_2021.txt",DataFrame,delim="\t",missingstring=NA)
```

Unlike `R`, if the package is not installed `Julia` will just ask if you would like to install it, and if you say yes, it will automatically load it after installation. Now that you have the data open, let's take a look at it!

## Re-creating the main plot in Buffalo 2021

Data exploration is often visual - it's a good idea to see what the distribution of data looks like before you decide what statistical model to use on it. We'll start with a relatively simple plot: a scatter plot of the population size vs genetic diversity. To do this you'll need to figure out some basics of how to refer to different data columns in your language of choice. Code to plot this will be your first reportable bit for the lab. If you are already comfortable plotting data - great! Focus on the rest of the lab and skip ahead to

## Plotting in `R`

Start by checking the opened data. Just like bash, `R` also has a `head` command. If you run

```{r}
#| eval: false
#| echo: true

head(buffalo_data)
```

You should see:

```{output}
# A tibble: 6 × 60
  species             phylum habitat mating_system range_cat sexual_system abbrv
  <chr>               <chr>  <chr>   <chr>         <chr>     <chr>         <chr>
1 Abatus agassizi     Echin… NA      NA            NA        NA            NA   
2 Acromyrmex echinat… Arthr… NA      NA            NA        male.haploid  NA   
3 Acropora millepora  Cnida… NA      NA            NA        hermaphrodite NA   
4 Acyrthosiphon pisum Arthr… Terres… Partial self… Cosmopol… parthenogenic NA   
5 Aedes aegypti       Arthr… Terres… Obligatory o… Cosmopol… gonochorous   NA   
6 Aedes albopictus    Arthr… NA      NA            NA        gonochorous   NA   
```

Note a couple of things: the data contains 60 columns, the names of the first 8 of which are listed above. Under each name of column the data type is specified (in this case, all `chr` - character data, e.g. text strings). Not visible in this text, but hopefully in yours - the NA entries should be a different color, highlighting where data is missing.

You might want to know all of the different columns available: you can get that list by asking for the `names` of the data

```{r}
#| echo: true
#| eval: false
names(buffalo_data)
```

And you should see:

```{output}
 [1] "species"               "phylum"                "habitat"              
 [4] "mating_system"         "range_cat"             "sexual_system"        
 [7] "abbrv"                 "neut_model_conf"       "genome_species"       
[10] "self_est"              "maplen_data_source"    "diversity_data_source"
[13] "site_type"             "hcn"                   "num_markers"          
[16] "parpath"               "pred_pi"               "impact_of_sel"        
[19] "log10_size"            "log10_range"           "num_chr"              
[22] "totalMb_covered"       "ave_rec"               "assembly_size"        
[25] "selfing"               "map_length"            "genome_size"          
[28] "fecundity"             "propagule"             "bodymass_g"           
[31] "diversity"             "size"                  "log10_diversity"      
[34] "social"                "species_orig"          "is_terrestrial"       
[37] "n_occ"                 "range"                 "id"                   
[40] "kingdom"               "superphylum"           "subphylum"            
[43] "class"                 "order"                 "family"               
[46] "genus"                 "clean_name"            "redlist_cat"          
[49] "log10_body_mass"       "log10_body_mass_pred"  "log10_popsize"        
[52] "log10_density"         "log10_density_pred"    "pred_log10_body_mass" 
[55] "pred_log10_density"    "pred_log10_N"          "RS"                   
[58] "log10_RS"              "log10_map_length"      "species_lower" 
```

For your plot, you'll want to plot `pred_log10_N` against `log10_diversity`. Calling a column from a table is done as: `<your data frame>$<your column_name>`. So, to look at just the predicted log 10 population size, you might call `buffalo_data$pred_log10_N`.

::: {.callout-tip appearance="minimal"}
## Hint

Hitting the `Tab` key will automatically try to fill out the rest of a variable/function name in `R`, and will even give you an overview of arguments one could call. Don't be shy about mashing the `Tab` key as you code, just to avoid any coding issues.
:::

*How* you plot is an exercise left to the reader. You can do a very basic plot with `R`s innate `plot` functions, but I would recommend taking the time to look at something like `ggplot2` (follow [this](https://ggplot2.tidyverse.org/articles/ggplot2.html) guide, but just substitute your data in.)

## Plotting in `Julia`

Before we plot, let's see how the code differs compared to `R`. Just like `R`, we can take a look at the head of the data, but that's done by default when you import the data. So you should have already seen something like:

```{julia-output}
300×60 DataFrame
 Row │ species                      phylum         habitat      mating_system           range_cat       sexual_system  abbrv     neut_model_conf  genome_species  self_est  maplen_data_source  diversity_data_source  site_type  hc ⋯
     │ String                       String15       String31?    String31?               String15?       String31?      String7?  String3?         String31?       Float64?  String31?           String31?              Missing    In ⋯
─────┼────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
   1 │ Abatus agassizi              Echinodermata  missing      missing                 missing         missing        missing   missing          missing          missing  missing             Romiguier et al.         missing  mi ⋯
   2 │ Acromyrmex echinatior        Arthropoda     missing      missing                 missing         male.haploid   missing   missing          missing          missing  Stapley et al.      missing                  missing 
   3 │ Acropora millepora           Cnidaria       missing      missing                 missing         hermaphrodite  missing   missing          missing          missing  Stapley et al.      missing                  missing 
   4 │ Acyrthosiphon pisum          Arthropoda     Terrestrial  Partial selfing         Cosmopolitan    parthenogenic  missing   missing          missing          missing  Stapley et al.      Leffler et al.           missing 
   5 │ Aedes aegypti                Arthropoda     Terrestrial  Obligatory outcrossing  Cosmopolitan    gonochorous    missing   missing          missing          missing  Stapley et al.      Leffler et al.           missing     ⋯
   6 │ Aedes albopictus             Arthropoda     missing      missing                 missing         gonochorous    missing   missing          missing          missing  Stapley et al.      missing                  missing 
   7 │ Agelaius phoeniceus          Chordata       Terrestrial  Obligatory outcrossing  Broad endemic   missing        missing   missing          missing          missing  missing             Leffler et al.           missing  mi
   8 │ Ailuropoda melanoleuca       Chordata       Terrestrial  Obligatory outcrossing  Narrow endemic  missing        missing   missing          missing          missing  missing             Leffler et al.           missing  mi
  ⋮  │              ⋮                     ⋮             ⋮                 ⋮                   ⋮               ⋮           ⋮             ⋮               ⋮            ⋮              ⋮                     ⋮                ⋮         ⋱
 294 │ Tupaia belangeri             Chordata       Terrestrial  Obligatory outcrossing  Broad endemic   missing        missing   missing          missing          missing  missing             Leffler et al.           missing  mi ⋯
 295 │ Varecia variegata            Chordata       missing      missing                 missing         missing        missing   missing          missing          missing  missing             Romiguier et al.         missing  mi
 296 │ Varecia variegata variegata  Chordata       Terrestrial  Obligatory outcrossing  Island          missing        missing   missing          missing          missing  missing             Leffler et al.           missing  mi
 297 │ Vespula vulgaris             Arthropoda     missing      missing                 missing         male.haploid   missing   missing          missing          missing  Stapley et al.      missing                  missing 
 298 │ Xenopus tropicalis           Chordata       missing      missing                 missing         gonochorous    missing   missing          missing          missing  Stapley et al.      missing                  missing     ⋯
 299 │ Xiphophorus maculatus        Chordata       missing      missing                 missing         gonochorous    missing   missing          missing          missing  Stapley et al.      missing                  missing 
 300 │ Zonotrichia albicollis       Chordata       Terrestrial  Obligatory outcrossing  Broad endemic   missing        missing   missing          missing          missing  missing             Leffler et al.           missing  mi
                                                                                                                                                                                                       47 columns and 285 rows omitte
```

A couple worthwile notes - `Julia` recoded the NAs as `missing`, which is a special type in `Julia`, and will give you headaches sometimes. Second, to save on memory, it has used the minimal size of String as the `type` for each column. For instance, no Phylum is longer than 15 characters, so it uses the String15 type, which has no more than 15 characters. These tiny optimizations add up to one of the reasons `Julia` performs much faster than `R` for big projects.

Julia has a bunch of approaches to plotting, probably more than either `R` or `python`, as there's lots of different subfields with their own plotting approaches. My goal is for you to write scripts *you* like using, so I'll recommend taking a look at the plotting backends [most are listed here](https://docs.juliaplots.org/dev/backends/) except for the `Makie` ecosystem, which you can take a glance at \[here\] . Overall - `Plots.jl` is a fine starting point, but `Makie` is popular because it allows some more fine-tuned customization for the plots. If you are working on a cluster, absolutely check out `UnicodePlots.jl`, as it can spit out nice summary plots without you having to download them/run interactive sessions.

The syntax to get a particular column in `Julia` is `<data_frame>.<column_name>`, so to get the population size you'd write `buffalo_data.pred_log10_N`. Now, follow the guide for your chosen plotting package and plot `N` versus `diversity`.

# Genomic data formats

As with any recent field, the proliferation of data has also meant a giant proliferation of data formats for genomic data. All of this is because of, generally, good intentions:

![](images/paste-2.png)

The format we'll focus on working with has *mostly* won out the fight for being *the* standard for genomic data: VCF (Variant Call Format). If you want the nitty gritty [here](https://samtools.github.io/hts-specs/VCFv4.2.pdf) is the standard description, with way too many details. Below is a shorter summary.

## How is a VCF file structured

### Header(s)

VCF files start with a whole bunch of lines starting with `##`. Some of these lines are mandatory, such as the first one which says which *version* of the VCF format is being used. Others are useful for good science, like keeping track of the commands that were used to generate this particular VCF. Additionally, there are many lines which determine what kind of details about the genotype calss are contained in the file. For today, we won't worry about almost all of them, as the file I'll have you play with is as basic as possible.

The final line before the data *actually* starts only has a single `#`, and is the real header. This has the names of each data column, including eight fixed fields:

```         
#CHROM   POS   ID    REF    ALT    QUAL    FILTER    INFO    FORMAT
```

These are: the chromosome the variant is on, its position, a unique ID, what allele is present in the reference, what alterante allele(s) are found in the data, the quality of the call as a \[PHRED\]() score, whether the site is filtered out or not, and an INFO column that can contain a lot of information about how the allele, and a FORMAT tab that tells you how the genotypes are listed. Generally, this will start with `GT`, and can then have various bits after a `:`, like `GT:GQ` means that you will first see the genotype, and then the genotype quality. The rest of the header is a list of your individual samples:

```         
#CHROM   POS   ID    REF    ALT    QUAL    FILTER    INFO   
FORMAT    Ind1     Ind2     Ind3   .... IndN
```

## Genotype information

After this, the file is a list of sites, each of which starts with the 8 fixed columns of info, and then presents the genotype for each individual. They look something like:

```         
#CHROM  POS     ID      REF     ALT     QUAL    FILTER  INFO    FORMAT  HG00096 HG00092
10   60523  rs148087467    T     G       100     PASS    -      GT:GL    0|0:-0.19  0/1:-0.12
```

What does this say? Well, individuals `HG00096` and `HG00092` have two different genotypes: `0|0` and `0/1` . A pipe character `|` means that the data is phased (we'll talk about this next week), while the `0/1` says that the data is unphased. `0`s indicate the reference allele (T, in this case), while 1 indicates the first ALT allele (G, in this case). You could also see something like:

```         
#CHROM  POS     ID      REF     ALT     QUAL    FILTER  INFO    FORMAT  HG00096 HG00092
8   11200  -    T     G,C,A       100     PASS    -      GT    1|2    0/3
```

This tells you the individuals have genotypes: GC and TA, respectively.

## Reading in VCF data

There are many genomics packages in `R`, and so there are many ways to read in a VCF. Today, I'll have you try the `vcfR` package: \[link\](<https://cran.r-project.org/web/packages/vcfR/index.html>), which is fairly minimal. Once you have the package installed and loaded, find the .vcf file in the \`labs/data\` folder of the repository, and read it in. Because in practice you'll often work with the genotype matrix, I've gone ahead and added a line that converts the vcf to a genotype matrix:

```{r}
#| echo: true
#| eval: false

require(vcfR)
vcf = read.vcfR("<path to file>")
GT = extract.gt(vcf,element="GT",as.numeric=TRUE)
```

The file I've constructed is extremely minimal, in that it only contains genotype data. The goal today is to write a function that can calculate the per-site heterozygosity of the data. I have a scaffold of a function set up below, but I want you to play around with the data and find what works for you to actually extract the information.

```{r}
#| echo: true
#| eval: false
h_vcf = function(gt_matrix){
    h_s = apply(gt_matrix,1,h_sample) # Apply takes a matrix (gt_matrix here), an argument specifying whether it should run across each row (1) or column(2) or entry(1:2), and a function to apply to that row/column. 
    return(sum(h_s)/dim(gt_matrix)[1]) #h_s will be heterozygosities at each site, so we take their average.
}

h_sample = function(site){
    #The above function makes sure you get passed an array of values, where 0 is aa, 1 is Aa and 2 is AA. How do we go from that to sample heterozygosity? 
    #Take a look at the lecture notes. Remember that you need to account for how many sites are actually sampled.
    allele_frequency = ???
    n = ???
    h = ???
    return(h)
}
```

## Julia solution

You've already been given some code to calculate h_sample given a vector in class, so I'll instead ask you to calculate the Site Frequency Spectrum. Of course, feel free to work out by yourself how you would calculate `h` (the two are very closely linked). In `Julia`, the best package to deal with `vcf` files is `VCFTools`. Unlike `vcfR`, it will not try to read in and keep the whole vcf in memory. Rather, it has many utility functions to quickly allow you to read in only the data you are interested in. So, to get out the genotype matrix, you would run:

```{julia}
#| echo: true
#| eval: false

using VCFTools

gt_matrix = convert_gt(Int8,"<path to vcf>";model=:additive,impute=false,scale=false,center=false)
```

Notice that because `Julia` is often column centric, each individual is a row, and each column is now a variant, unlike the VCF. Now, to calculate the SFS, you'll want to map a function that calculates frequency across the data.

```{julia}
#| echo: true
#| eval: false

function frequency(site)
    freq = missing #Think about how you'd get allele frequencies from a genotype matrix. How do you account for missing data?
    return(freq)
end

sitefreqs = [frequency(i) for i in eachcol(gt_matrix)]
```

## Bonus: Plot your heterozygosities

Now that you have hopefully learned both how to plot data, and how to calculate heterozygosity (or the SFS), try to plot your data. As you do so, keep track of what bits of code you keep re-running/re-using. Could you have written your code in a way that made those bits modular? (e.g.: functions that are called, so that you only need to maintain one copy of the function).

# Why do I need to write my own code for heterozygosity? Isn't there software for this?

Absolutely! The problem is that different software packages make different assumptions/concessions when it comes to any population genetic analyses. In general, for any publication I would recommend using a well vetted external package for your final version, but I would also try to verify at least some of the analysis with your own code. For instance, if you use something like `vcftools --het` to calculate heterozygosity, it will *skip* any sites with missing data entirely, and also assume that any site *not* in the VCF is the reference allele (e.g. het==0). That means that it often under-estimates heterozygosity, especially when there is a lot of missing data. On the other hand, something like `pixy` ([link](https://github.com/ksamuk/pixy)) will do a much more thorough job (although see [@konopinski2022]), but requires you to prepare your vcf files in a specific way. `ANGSD` is a fairly good method, but requires you to convert your VCFs into `PLINK` input files (`.bed .bim .fam`). The estimates often don't *exactly* agree, and so it's good to understand what goes into coding *any* estimator, let alone a more robust one as implemented in many popular packages. The good news: SNP based estimates are probably robust [@miller2013], but keep in mind how these approaches work. To compare with what you obtained, try to run the following approaches:

1\) `diversity.stats` from the `PopGenome` library in `R`: [link](https://popgenome.weebly.com/)

2\) `vftools labs/data/test_data.vcf.gz --het` You can do this on the HPC if you have access, or just install `vcftools` locally: [link](https://vcftools.github.io/index.html). This is optional - if you have trouble setting up vcftools on your machine, don't worry about this for the moment, but I'm happy to help you get set-up.

3\) `nucleotideDiversity` from `strataG` in `R`. You'll need to convert the vcf to a `genlight` object, good luck!

You will probably find that each gives a subtly different answer - that is why population genomics studies are more and more persnickety about you specifying *exactly* what you did and how you got your results, as each pipeline is bespoke and has unique flaws that no others do.